# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1J1kswaQs5GZSEdZ44LTvaJojpslgl1wC

#import dataset from kaggle website
"""

from google.colab import files
files.upload()

#download Saving kaggle.json to kaggle.json

#{'kaggle.json': b'{"username":,"key":"125465kjff"}'}

# Commented out IPython magic to ensure Python compatibility.
!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json
!kaggle datasets download -d uciml/iris
# %cd /content
import zipfile
zip_ref = zipfile.ZipFile('iris.zip', 'r')
zip_ref.extractall('iris.cv')
zip_ref.close()

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
# %cd /content/iris.cv
datasets=pd.read_csv('Iris.csv')
X = datasets.iloc[:120,:]
#shuffle
X=X.sample(frac=1)
X.loc[X['Species']== 'Iris-setosa','Species']=0
X.loc[X['Species']=='Iris-versicolor','Species']=1
X.loc[X['Species']== 'Iris-virginica', 'Species']=2
X=X.apply(pd.to_numeric)# convert to numeric
df=X.values

# we have 5 colomns
# 0 until 4 for xtrain
# 4 for ytrain
df_array.shape
xtrain=df[:100,:4]
ytrain=df[:100,5]

#build model:
import numpy as np
import torch
from torch import nn
import torch.nn.functional as F
torch.manual_seed(1234)
#hyperparameters
hl = 10  # تعداد لایه های اول
lr = 0.1
num_epoch = 10000
class Net(nn.Module):
  def __init__(self):
    super(Net,self).__init__()
    hl = 10
    self.component1=nn.Linear(4,10)#fully conected
    self.component2=nn.Linear(10,3)# tedad kelas
  def forward(self,x):
    x=F.leaky_relu(self.component1(x)) # activation function
          # خطی
    x = F.softmax(self.component2(x))# layer2
    return x
net = Net()
x=torch.Tensor(xtrain).float()
y=torch.Tensor(ytrain).long()#int
for epoch in range(num_epoch):
  criterion= nn.CrossEntropyLoss()
  optim=torch.optim.Adadelta(net.parameters(),lr=0.1)

  optim.zero_grad()
  y_pred=net(x)
  loss=criterion(y_pred,y)
  loss.backward()
  optim.step()
  if num_epoch%100==0:
    print('loss : %.4f' % loss.item())

net.component2.weight

#test
xtest=df[101:,:4]
ytest=df[101:,5]
xtest=torch.Tensor(xtest).float()
ytest=torch.Tensor(ytest).long()
out=net(xtest)
_,predicted=torch.max(out.data,1)
print('accuracy:',100*(torch.sum(predicted==ytest)/19))